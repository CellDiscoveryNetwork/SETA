---
title: "Multi-Resolution Compositional Analysis in scRNA-seq: Reference Frames with SETA"
date: "`r BiocStyle::doc_date()`"
author:
- name: Kyle Kimler
  affiliation:
  - &CDN Cell Discovery Network
  - &BCH Boston Children's Hospital
  - &UVIC-UCC University of Vic - Central University of Catalonia
  email: kkimler@broadinstitute.org
- name: Marc Elosua-Bayes
  affiliation: 
  - &CDN Cell Discovery Network
  - &BCH Boston Children's Hospital
  email: marc.elosuabayes@childrens.harvard.edu
package: "`r BiocStyle::pkg_ver('SETA')`"
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Multi-Resolution Compositional Analysis in scRNA-seq: Reference Frames with SETA}
  %\VignetteEngine{knitr::rmarkdown}
output: 
  BiocStyle::html_document
editor_options: 
  markdown: 
    wrap: 80
  chunk_output_type: console
---

```{=html}
<style type="text/css">
.smaller {
  font-size: 10px
}
</style>
```

## Introduction

`SETA` provides a set of functions for compositional analysis of single-cell RNA-seq data. In earlier vignettes, we introduced the basics of compositional transforms (`setaCLR`, `setaALR`, etc.) and distance/metadata handling. 

In this vignette, we demonstrate how to create and utilize _multi-resolution_ annotations—here referred to as **reference frames**—for hierarchical or subcompositional analysis. Our outline:

- **Extract a taxonomic data frame** of differing cell-type resolutions  
- **Visualize the taxonomy as a tree** using `ggraph`  
- **Transform counts data with a chosen taxonomic reference frame**  
- **Compare PCA latent spaces** based on different reference frames

This example uses a dataset from CELLxGENE stored in `"Covid_Flu_sceect_DF.rds"`. The dataset contains blood samples from 17 donors (`donor_id`) with disease annotations (`disease`: influenza, COVID-19, or normal), cell-type annotations (`free_annotation`), and additional metadata (e.g., `Severity`, `Comorbidity`, `development_stage`). Although the Seurat object does not inherently contain multi-resolution cell-type columns, we'll artificially define a broader “lineage” level for demonstration.

```{r setup, message=FALSE, warning=FALSE}
library(SingleCellExperiment)
library(SETA)
library(ggplot2)
library(ggraph)
library(tidygraph)
library(dplyr)
library(ggplot2)
library(patchwork)
library(TabulaMurisSenisData)
```

```{r}
# Set up a color palette for plots
# 9-group distinct categoricals
d_palette <- c("#3B9AB2", "#6BAFAF", "#9BBDAC", "#C9C171",
               "#EBCC2A", "#E6A80F", "#E98903", "#F84C00", "#F21A00")
```

## Load and prepare data

```{r, echo = FALSE}
sce <- TabulaMurisSenisDroplet(tissues = "Lung")$Lung
```

Quick data exploration:

```{r}
table(sce$free_annotation, sce$age)
```

## Creating a Taxonomic Data Frame
Below, we define a custom lineage column that lumps certain cell types together:

All Monocyte variants → Monocytes

All CD4/CD8 variants → T cells

All B cell variants → B cells

Everything else remains as is.

```{r add lineage information}
# We'll make a small mapping from original free_annotation -> broader 'Lineage'
lineage_map <- c(
  "Adventitial Fibroblast" = "Fibroblast",
  "Airway Smooth Muscle" = "SMC",
  "Alveolar Epithelial Type 2" = "Epithelial",
  "Alveolar Fibroblast" = "Fibroblast",
  "Alveolar Macrophage" = "Myeloid",
  "Artery" = "Endothelial",
  "B" = "B cell",
  "Basophil" = "Granulocyte",
  "Ccr7+ Dendritic" = "Myeloid",
  "CD4+ T" = "T cell",
  "CD8+ T" = "T cell",
  "Capillary" = "Endothelial",
  "Capillary Aerocyte" = "Endothelial",
  "Ciliated" = "Epithelial",
  "Classical Monocyte" = "Myeloid",
  "Club" = "Epithelial",
  "Intermediate Monocyte" = "Myeloid",
  "Interstitial Macrophage" = "Myeloid",
  "Lympatic" = "Endothelial",
  "Ly6g5b+ T" = "T cell",
  "Myeloid Dendritic Type 1" = "Myeloid",
  "Myeloid Dendritic Type 2" = "Myeloid",
  "Myofibroblast" = "Fibroblast",
  "Natural Killer" = "NK",
  "Natural Killer T" = "NK",
  "Neuroendocrine" = "Neuroendocrine",
  "Neutrophil" = "Granulocyte",
  "Nonclassical Monocyte" = "Myeloid",
  "Pericyte" = "Endothelial",
  "Plasma" = "Plasma Cell",
  "Plasmacytoid Dendritic" = "Myeloid",
  "Proliferating Alveolar Macrophage" = "Proliferating",
  "Proliferating Classical Monocyte" = "Proliferating",
  "Proliferating Dendritic" = "Proliferating",
  "Proliferating NK" = "Proliferating",
  "Proliferating T" = "Proliferating",
  "Regulatory T" = "T cell",
  "Vein" = "Endothelial",
  "Zbtb32+ B" = "B cell"
)

# Add a new column in  named 'Lineage'
free_annotations <- as.character(sce$free_annotation)
sce$Lineage <- lineage_map[free_annotations]
```

Now we can build a taxonomic data frame that has two levels: 
the fine label (free_annotation) and the broad label (Lineage). 

```{r create taxonomy DF}
# In a Seurat Object, barcodes are in the rownames of the metadata.
# Similar to setaCounts, taxonomy DF creation can use rownames as bc.
# Then we ensure we have columns for 'free_annotation' and 'Lineage'.
print(head(sce$free_annotation))
print(head(sce$Lineage))

# We want a data frame that includes bc + 'free_annotation' + 'Lineage'
# Then we'll pass it to setaTaxonomyDF
tax_df <- setaTaxonomyDF(
  obj = data.frame(colData(sce)),
  resolution_cols = c("Lineage", "free_annotation"),
  bc_col = "cell"
)

# Each row is a unique 'free_annotation'.
# The last column 'free_annotation' is the finer label.
# cols must be entered in order of increasing resolution (broadest to finest)
tax_df
```

## Visualize the Taxonomy as a Tree via ggraph

We now have a 2-level taxonomy: free_annotation (fine) -> Lineage (coarse). 
For demonstration, let's build a small graph that connects each free_annotation node to its Lineage node. 
We'll color edges by the lineage label:

```{r ggraph, message=FALSE, warning=FALSE, fig.width = 8, fig.height = 6}
# Create a tidygraph object using SETA built-in utils
tbl_g <- taxonomy_to_tbl_graph(
    tax_df,
    columns = c("Lineage", "free_annotation"))

# Plot with ggraph
ggraph(tbl_g, layout = "dendrogram") +
    geom_edge_diagonal2(aes(color = node.Lineage)) +
    geom_node_text(aes(filter = leaf,
                       label = free_annotation, color = Lineage),
                   nudge_y = 0.1, vjust = 0.5, hjust = 0, size = 5) +
    geom_node_text(aes(filter = !leaf,
                       label = Lineage),
                   color = 'black',
                   size = 5,
                   repel = TRUE) +
    guides(edge_colour = guide_legend(title = "Lineage"),
           color = guide_legend(title = "Lineage")) +
    theme_linedraw(base_size = 16) +
    scale_edge_color_manual(values = d_palette) +
    scale_color_manual(values = d_palette) +
    scale_y_reverse(breaks = seq(0, 2, by = 1),
                    labels = c("Type", "Lineage", "Root")) +
    theme(axis.text.y = element_blank()) +
    expand_limits(y = -5) +
    coord_flip() +
    ggtitle("SETA: Taxonomy") 
```

Here, each Lineage is a parent node, and each free_annotation is a leaf node.
The edges are colored by the lineage name.


## Transform Counts with a Taxonomic Reference Frame

We can now use setaCounts to get the sample × free_annotation matrix, 
then apply a within-lineage transform. 
This lumps certain columns (cell types) into subcompositions. 
For example, a CLR transform within each lineage:

```{r reference frame calculation}
# Create sample x free_annotation counts:
taxa_counts <- setaCounts(
    sce,
    cell_type_col = "free_annotation",
    sample_col = "donor_id",
    bc_col = "rownames"
)

# We'll transform them with a 'Lineage' grouping.
# The taxonomyDF uses rownames = free_annotation
# so that colnames(taxa_counts) align with rownames(tax_df).
refframe_out <- setaTransform(
    counts            = taxa_counts,
    method            = "CLR",
    taxonomyDF        = tax_df,
    taxonomy_col      = "Lineage",
    within_resolution = TRUE
)
refframe_out$within_resolution
refframe_out$grouping_var

# Compare to a standard global CLR transform:
global_out <- setaTransform(taxa_counts, method = "CLR")
```


## Visualize Latent Spaces With Different Reference Frames

Below we show how to do PCA on the sample-level coordinates from either the global CLR or the lineage-based CLR. 
We color points by disease to see if the subcompositional approach changes clustering.

```{r latent reference frames, fig.width = 10, fig.height = 6}
# A) Global CLR
latent_global <- setaLatent(global_out, method = "PCA", dims = 2)
pca_global <- latent_global$latentSpace
pca_global$sample <- rownames(pca_global)

# B) Within-Lineage CLR
latent_lineage <- setaLatent(refframe_out, method = "PCA", dims = 2)
pca_lineage <- latent_lineage$latentSpace
pca_lineage$sample <- rownames(pca_lineage)

# Merge with metadata
meta_df <- setaMetadata(sce, sample_col = "Sample ID",
                        meta_cols = c("Disease group", "Severity"))
pca_global <- left_join(pca_global, meta_df, by = c("sample" = "Sample ID"))
pca_lineage <- left_join(pca_lineage, meta_df, by = c("sample" = "Sample ID"))

# Plot side by side
p1 <- ggplot(pca_global, aes(x = PC1, y = PC2, color = Disease.group)) +
    geom_text(aes(label = sample)) +
    scale_color_manual(
        values = d_palette
    ) +
    labs(title = "Global CLR PCA",
        x = "PC1", y = "PC2", color = "Disease Status") +
    theme_minimal() +
    xlab(sprintf("PC1 (%s%%)",
                 signif(latent_global$varExplained[1], 4) * 100)) +
    ylab(sprintf("PC2 (%s%%)",
                 signif(latent_global$varExplained[2], 4) * 100)) +
    theme(legend.position = 'none')

p2 <- ggplot(pca_lineage, aes(x = PC1, y = PC2, color = Disease.group)) +
    geom_text(aes(label = sample)) +
    scale_color_manual(
        values = d_palette
    ) +
    labs(title = "Within-Lineage CLR PCA",
        x = "PC1", y = "PC2", color = "Disease Status") +
    theme_minimal() +
    xlab(sprintf("PC1 (%s%%)",
                 signif(latent_lineage$varExplained[1], 4) * 100)) +
    ylab(sprintf("PC2 (%s%%)",
                 signif(latent_lineage$varExplained[2], 4) * 100))


p1 + p2
```

```{r}
sessionInfo()
```