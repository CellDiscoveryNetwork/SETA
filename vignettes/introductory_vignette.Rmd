---
title: "Introduction to SETA ecological transforms and sample-level latent spaces"
author: "Kyle Kimler"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to SETA ecological transforms and sample-level latent spaces}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


## Introduction

`SETA` provides a set of functions for compositional analysis of single-cell RNA-seq data.

In this vignette we show how to:
  
- **Extract a taxonomic counts matrix** from various objects (e.g. a Seurat object)
- **Apply compositional transforms** such as CLR and ALR
- **Compute a latent space** using PCA (with options for PCoA or NMDS)

This example uses a dataset from CELLxGENE stored in `"Covid_Flu_Seurat_Object_DF.rds"`. 
The dataset contains blood samples from 17 donors (`donor_id`), with disease annotations (`disease`: influenza, COVID-19, or normal), cell-type annotations (`Celltype`), and additional metadata (e.g. `Severity`, `Comorbidity`, and `development_stage`).

*This vignette is modular; users can update or replace the dataset-specific settings*
*(e.g., metadata column names, reference cell type) as appropriate for their own data.*


## Loading the Data

In this example we assume the Seurat object is stored as an RDS file.
We load the object along with the required package (`Seurat`) and our package (`SETA`).

```{r, echo=FALSE, message=FALSE, warning=FALSE}
base_path <- "/Users/kylekimler/gitHub/workshops/"
data_loc <- paste0(base_path, "beginners-guide-to-analyzing-scRNAseq/data/")
```

```{r setup, message=FALSE, warning=FALSE, echo=TRUE}
library(Seurat)
library(SETA)
library(ggplot2)
library(dplyr)

# Modify the file path if needed
seurat_file <- paste0(data_loc, "Covid_Flu_Seurat_Object_DF.rds")
seurat_obj <- readRDS(seurat_file)
```

```{r}
# Set up a color palette for plots
# 5-group distinct categoricals
d_palette <- c("#3B9AB2", "#9BBDAC", "#EBCC2A", "#E98903", "#F21A00")
```

## Extracting the Taxonomic Counts Matrix

The setaCounts function extracts a cell-type counts matrix given 
that the object contains cell‐level metadata. For this dataset, 
we want the cell-type annotations to come from Celltype and 
the sample identifiers from donor_id. If necessary, 
we reassign these columns before extraction.

```{r data wrangling, message=FALSE, warning=FALSE, echo=TRUE}
# Extract the taxonomic counts matrix using custom metadata column names
# (Users can specify these column names according to their dataset.)
taxa_counts <- setaCounts(seurat_obj@meta.data,
                          cell_type_col = "Celltype",
                          sample_col = "Sample ID",
                          bc_col = "rownames")
print(head(taxa_counts))
```


## Applying Compositional Transforms

Below we apply two transforms:

The centered log-ratio (CLR) transform,

The additive log-ratio (ALR) transform.

For the ALR transform we need to choose a reference cell type.
In this example, we assume that one of the cell types is "Bcell".
If it does not exist in your dataset, change the reference accordingly.

```{r transformation, echo=TRUE}
# CLR Transformation with a pseudocount of 1 (default)
clr_out <- setaCLR(taxa_counts, pseudocount = 1)
print(head(clr_out$counts))

# ALR Transformation: using "NK cell" as the reference cell type
if ("NK cell" %in% rownames(taxa_counts)) {
  alr_out <- setaALR(taxa_counts, ref = "NK cell", pseudocount = 1)
  print(head(alr_out$counts))
} else {
  message("Reference 'NK cell' not found in taxa_counts. 
            Please choose an available cell type.")
}

# ILR Transform using Helmert basis (boxcox_p = 0 for standard ILR)
# This is the method used by Cacoa (Viktor Petukhov & Kharchenko Lab)
ilr_out <- setaILR(taxa_counts, boxcox_p = 0, pseudocount = 1)
print(head(ilr_out$counts))

# Simple Percentage Transform
pct_out <- setaPercent(taxa_counts)
print(head(pct_out$counts))

# LogCPM (counts per 10k) Transform
lcpm_out <- setaLogCPM(taxa_counts, pseudocount = 1)
print(head(lcpm_out$counts))
```

## Latent Space Analysis
```{r latent spaces, echo=TRUE}
latent_pca <- setaLatent(clr_out, method = "PCA", dims = 5)
# PCA Latent Space Coordinates:
print(head(latent_pca$latentSpace))
# Variance Explained:
print(latent_pca$varExplained)
```

## Visualization
Below we show how to create basic visualizations of SETA latent spaces

### Variance Explained Plot
Plot the variance explained by the first few principal components.

```{r variance explained, message=FALSE, warning=FALSE, echo=TRUE}
ve_df <- data.frame(
  PC = factor(seq_along(latent_pca$varExplained), 
              levels = seq_along(latent_pca$varExplained)),
  VarianceExplained = cumsum(latent_pca$varExplained)
)
```
```{r, fig.width = 6, fig.height = 4}
ggplot(ve_df, aes(x = PC, y = VarianceExplained)) +
    geom_line(color = "#2ca1db", size = 1.5, stat = "identity") +
    geom_point(color = "#f44323", size = 3) +
    labs(title = "Cumulative Variance Explained by Principal Components",
         x = "Principal Component", y = "Cumulative Variance Explained (%)") +
    theme_minimal() +
    ylim(c(0, 1)) +
    theme(text = element_text(size = 12))
```

### PCA Scatter plot
We overlay the PCA latent space coordinates (using the CLR transform) 
with metadata from the Seurat object. 
In this example, points are shaped by disease and colored by Severity. 

```{r, PCA scatter}
# Extract latent space coordinates from PCA result.
pca_coords <- latent_pca$latentSpace

# Extract metadata
meta_df <- setaMetadata(seurat_obj,
                        sample_col = "Sample ID",
                        meta_cols = c("disease", "Disease group"))

# Merge latent coordinates with metadata
pca_plot_df <- cbind(pca_coords, meta_df)
```

```{r, fig.width = 6, fig.height = 4}
# Create the scatter plot
ggplot(pca_plot_df, aes(x = PC1, y = PC2, color = Disease.group)) +
    geom_text(aes(label = `Sample ID`)) +
    scale_color_manual(
      values = d_palette
    ) +
    labs(title = "PCA Scatter Plot",
        x = "PC1", y = "PC2", color = "Disease Status") +
    theme_minimal() +
    xlab(sprintf("PC1 (%s%%)", signif(latent_pca$varExplained[1], 4) * 100)) +
    ylab(sprintf("PC2 (%s%%)", signif(latent_pca$varExplained[2], 4) * 100))
```

### Loadings Plot
Plot the variance explained by interesting principal components.

```{r loadings, message=FALSE, warning=FALSE, echo=TRUE}
loadings_df <- as.data.frame(latent_pca$loadings)
loadings_df$Celltype <- rownames(loadings_df)

# Melt the loadings into long format for ggplot2
library(reshape2)
loadings_long <- melt(loadings_df, id.vars = "Celltype",
                      variable.name = "PC", value.name = "Loading")

# For each PC, select top and bottom 5 based on absolute loading values
library(dplyr)
loadings_summary <- loadings_long %>%
    group_by(PC) %>%
    arrange(desc(Loading)) %>%
    ungroup()
```
```{r, fig.width = 4, fig.height = 3}
ggplot(loadings_summary %>%
       filter(PC == "PC1") %>%
       mutate(Celltype = factor(Celltype, levels = Celltype)),
       aes(x = Loading, y = Celltype, label = Celltype)) +
    geom_text(size = 3) +
    facet_wrap(~PC, scales = "free") +
    labs(title = "PC1 Loadings",
         x = "Loading", y = "Cell Type") +
    theme_minimal() +
    expand_limits(x = c(-0.2, 0.4)) +
    theme(axis.text.y = element_blank())
```

```{r, fig.width = 4, fig.height = 3}
ggplot(loadings_summary %>%
       filter(PC == "PC2") %>%
       mutate(Celltype = factor(Celltype, levels = Celltype)),
       aes(x = Loading, y = Celltype, label = Celltype)) +
    geom_text(size = 3) +
    facet_wrap(~PC, scales = "free") +
    labs(title = "PC2 Loadings",
         x = "Loading", y = "Cell Type") +
    theme_minimal() +
    expand_limits(x = c(-0.2, 0.4)) +
    theme(axis.text.y = element_blank())
```

## Conclusion
This vignette illustrated a basic workflow using the SETA package:

1. Extracting a taxonomic counts matrix from a Seurat Object with setaCounts

2. Applying compositional transforms (CLR, ALR, ILR, and simple transforms)

3. Performing latent space analysis (PCA)

4. Visualizing sample-level latent spaces

Each step is modular, so you can easily swap in your own data, 
update metadata column names, or choose different parameters 
(e.g., pseudocount, reference cell type) to suit your analysis needs.

For further details, see the package documentation and 
relevant literature on compositional data analysis (e.g., Aitchison, 1982).

```{r}
sessionInfo()
```